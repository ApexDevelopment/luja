enum LuaConstant {
	Nil
	Boolean(value: bool)
	Number(value: f64)
	LString(value: String)
}

enum LuaValue {
	Constant(constant: LuaConstant)
	LuaFunction(lfunction: LuaScope)
	NonLuaFunction(function_name: String)
	Table(table_id: u64)
}

class LuaLocal {
	public name: String
	public scope_start: usize
	public scope_end: usize
}

class LuaInstruction {
	public opcode: u8
	public A: u32
	public B: u32
	public C: u32
	public Bx: u32
	public sBx: i32
}

class LuaChunk {
	public source_name: String
	public source_line_start: usize
	public source_line_end: usize
	public number_of_upvalues: u8
	public number_of_parameters: u8
	public is_vararg: u8
	public max_stack_size: u8
	public instruction_list: [LuaInstruction]
	public constant_list: [LuaConstant]
	public prototype_list: [LuaChunk]
	public source_line_list: [usize]
	public local_list: [LuaLocal]
	public upvalue_list: [String]
}

class LuaHeader {
	public version: u8
	public format: u8
	public endianness: u8
	public size_int: usize
	public size_size_t: usize
	public size_instruction: usize
	public size_lua_number: usize
	public number_type: u8
}

class LuaEnvironment {
	public function get_global(this, global: LuaValue) -> LuaValue {
		guard global is Constant(constant) else {
			return LuaValue::Constant(constant: LuaConstant::Nil)
		}

		guard constant is LString(value) else {
			return LuaValue::Constant(constant: LuaConstant::Nil)
		}

		if value == "print" {
			return LuaValue::NonLuaFunction(function_name: value)
		}
	}
}

function print_lua_values(values: [LuaValue]) throws {
	mut string_builder: StringBuilder = StringBuilder::create()

	for value_index in 0 .. values.size() {
		let lua_value = values[value_index]

		match lua_value {
			Constant(constant) => {
				match constant {
					Nil => {
						string_builder.append_string("nil")
					}
					Boolean(value) => {
						if value {
							string_builder.append_string("true")
						}
						else {
							string_builder.append_string("false")
						}
					}
					Number(value) => {
						string_builder.append_string(format("{}", value))
					}
					LString(value) => {
						string_builder.append_string(value)
					}
				}
			}
			else => {}
		}

		string_builder.append(b'\t')
	}

	println(string_builder.to_string())
}

class LuaScope {
	public environment: LuaEnvironment
	public prototype: LuaChunk
	public registers: [LuaValue]
	public pc: usize

	public function construct(environment: LuaEnvironment, prototype: LuaChunk, arguments: [LuaValue]) throws -> LuaScope {
		mut registers: [LuaValue] = [LuaValue::Constant(constant: LuaConstant::Nil); prototype.max_stack_size]

		for argument_index in 0 .. arguments.size() {
			registers.push(arguments[argument_index])
		}

		return LuaScope(environment, prototype, registers, pc: 0)
	}

	public function run_instruction(mut this, instruction_index: usize) throws {
		guard instruction_index < .prototype.instruction_list.size() else {
			eprintln("Instruction {} does not exist", instruction_index)
			return
		}

		let instruction = .prototype.instruction_list[instruction_index]

		match instruction.opcode {
			0 => { // MOVE
				.registers[instruction.A] = .registers[instruction.B]
			}
			1 => { // LOADK
				.registers[instruction.A] = LuaValue::Constant(constant: .prototype.constant_list[instruction.Bx])
			}
			2 => { // LOADBOOL
				.registers[instruction.A] = LuaValue::Constant(constant: LuaConstant::Boolean(value: instruction.B != 0))

				if (instruction.C != 0) { .pc++ }
			}
			3 => { // LOADNIL
				for register_index in instruction.A .. instruction.B {
					.registers[register_index] = LuaValue::Constant(constant: LuaConstant::Nil)
				}
			}
			4 => {
				// TODO: GETUPVAL
			}
			5 => { // GETGLOBAL
				let global = LuaValue::Constant(constant: .prototype.constant_list[instruction.Bx])
				.registers[instruction.A] = .environment.get_global(global)
			}
			6 => {
				// TODO: SETUPVAL
			}
			28 => { // CALL
				let function_to_call = .registers[instruction.A]

				guard function_to_call is NonLuaFunction(function_name) else {
					eprintln("TODO: Call lua funcs")
					throw Error::from_errno(1)
				}

				if function_name == "print" {
					print_lua_values(values: .registers[(instruction.A + 1) .. (instruction.A + instruction.B)].to_array())
				}
			}
			else => {
				eprintln("Unknown opcode {} at instruction {}", instruction.opcode, instruction_index)
			}
		}
	}
}