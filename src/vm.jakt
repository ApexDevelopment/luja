import luatypes { LuaConstant, LuaValue, LuaChunk }

fn print_lua_values(values: [LuaValue]) throws {
	mut string_builder: StringBuilder = StringBuilder::create()

	for value_index in 0 .. values.size() {
		let lua_value = values[value_index]

		match lua_value {
			Constant(constant) => {
				match constant {
					Nil => {
						string_builder.append("nil")
					}
					Boolean(value) => {
						if value {
							string_builder.append("true")
						}
						else {
							string_builder.append("false")
						}
					}
					Number(value) => {
						string_builder.append(format("{}", value))
					}
					LString(value) => {
						string_builder.append(value)
					}
				}
			}
			else => {}
		}

		string_builder.append(b'\t')
	}

	println("{}", string_builder.to_string())
}

class LuaEnvironment {
	public fn get_global(this, anon global: LuaValue) -> LuaValue {
		guard global is Constant(constant) else {
			return LuaValue::Constant(LuaConstant::Nil)
		}

		guard constant is LString(value) else {
			return LuaValue::Constant(LuaConstant::Nil)
		}

		if value == "print" {
			return LuaValue::NonLuaFunction(value)
		}

		return LuaValue::Constant(LuaConstant::Nil)
	}

	public fn set_global(this, anon global: LuaValue, anon new_value: LuaValue) {
		guard global is Constant(constant) else {
			return
		}

		guard constant is LString(value) else {
			return
		}

		println("Set global {} to {}", value, new_value)
	}
}

enum LuaInstructionResult {
	VMError(message: String)
	Error(message: String)
	Continue
	Return
}

class LuaScope {
	public environment: LuaEnvironment
	public prototype: LuaChunk
	public registers: [LuaValue]
	public pc: usize

	public fn construct(environment: LuaEnvironment, prototype: LuaChunk, arguments: [LuaValue]) throws -> LuaScope {
		mut registers: [LuaValue] = [LuaValue::Constant(LuaConstant::Nil); prototype.max_stack_size]

		for argument_index in 0 .. arguments.size() {
			registers.push(arguments[argument_index])
		}

		return LuaScope(environment, prototype, registers, pc: 0)
	}

	public fn run_instruction(mut this, instruction_index: usize) throws -> LuaInstructionResult {
		guard instruction_index < .prototype.instruction_list.size() else {
			let message = format("Instruction index {} does not exist", instruction_index)
			return LuaInstructionResult::VMError(message)
		}

		let instruction = .prototype.instruction_list[instruction_index]

		let result: LuaInstructionResult = match instruction.opcode {
			0 => { // MOVE
				.registers[instruction.A] = .registers[instruction.B]
				yield LuaInstructionResult::Continue()
			}
			1 => { // LOADK
				.registers[instruction.A] = LuaValue::Constant(.prototype.constant_list[instruction.Bx])
				yield LuaInstructionResult::Continue()
			}
			2 => { // LOADBOOL
				.registers[instruction.A] = LuaValue::Constant(LuaConstant::Boolean(value: instruction.B != 0))

				if (instruction.C != 0) { .pc++ }
				yield LuaInstructionResult::Continue()
			}
			3 => { // LOADNIL
				for register_index in instruction.A .. instruction.B {
					.registers[register_index] = LuaValue::Constant(LuaConstant::Nil)
				}

				yield LuaInstructionResult::Continue()
			}
			4 => {
				// TODO: GETUPVAL
				yield LuaInstructionResult::Continue()
			}
			5 => { // GETGLOBAL
				let global = LuaValue::Constant(.prototype.constant_list[instruction.Bx])
				.registers[instruction.A] = .environment.get_global(global)
				yield LuaInstructionResult::Continue()
			}
			6 => {
				// TODO: GETTABLE
				yield LuaInstructionResult::Continue()
			}
			7 => { // SETGLOBAL
				let global = LuaValue::Constant(.prototype.constant_list[instruction.Bx])
				.environment.set_global(global, .registers[instruction.A])
				yield LuaInstructionResult::Continue()
			}
			8 => {
				// TODO: SETUPVAL
				yield LuaInstructionResult::Continue()
			}
			9 => {
				// TODO: SETTABLE
				yield LuaInstructionResult::Continue()
			}
			21 => { // CONCAT
				mut string_builder = StringBuilder::create()

				for register_index in instruction.B .. (instruction.C + 1) {
					let value = .registers[register_index]

					// We don't have nested match in Jakt at the time of writing
					if (value is Constant(constant)) {
						if (constant is LString(value)) {
							string_builder.append(value)
						}
						else if (constant is Number(value)) {
							string_builder.append(format("{}", value))
						}
						else if (constant is Boolean(value)) {
							if value {
								string_builder.append("true")
							}
							else {
								string_builder.append("false")
							}
						}
						else if (constant is Nil) {
							string_builder.append("nil")
						}
					}
					else {
						// Yield isn't allowed here for some reason
						return LuaInstructionResult::VMError(message: format("Unsupported value type in CONCAT: {}", value))
					}
				}

				.registers[instruction.A] = LuaValue::Constant(LuaConstant::LString(value: string_builder.to_string()))
				yield LuaInstructionResult::Continue()
			}
			28 => { // CALL
				let function_to_call = .registers[instruction.A]

				guard function_to_call is NonLuaFunction(function_name) else {
					eprintln("TODO: Call lua funcs")
					throw Error::from_errno(1)
				}

				if function_name == "print" {
					print_lua_values(values: .registers[(instruction.A + 1) .. (instruction.A + instruction.B)].to_array())
				}
				
				yield LuaInstructionResult::Continue()
			}
			else => {
				mut string_builder = StringBuilder::create()
				string_builder.append(format("Unknown opcode {} at instruction {}", instruction.opcode, instruction_index))
				if (.prototype.source_line_list.size() > instruction_index) {
					let line_number = .prototype.source_line_list[instruction_index]
					string_builder.append(format(" (source line {})", line_number))
				}
				yield LuaInstructionResult::VMError(message: string_builder.to_string())
			}
		}

		return result
	}

	public fn run_to_completion(mut this) throws {
		mut result = LuaInstructionResult::Continue()

		while .pc < .prototype.instruction_list.size() and result is Continue {
			result = .run_instruction(instruction_index: .pc)
			.pc++
		}

		match result {
			VMError(message) => {
				eprintln("VM Error: {}", message)
			}
			Error(message) => {
				eprintln("Error: {}", message)
			}
			else => {}
		}
	}
}